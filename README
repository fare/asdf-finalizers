ASDF-FINALIZERS

This library allows you to implement and enforce proper finalization
of compile-time constructs while building Lisp source files.
It depends on ASDF 2.22.3 or later.

TODO:
* Add XCVB support.


==== Exported Functionality ====

asdf-finalizers defines and uses package ASDF-FINALIZERS.
It uses ASDF 2.22.3's :around-compile hook mechanism and
the :compile-check extension to its compile-file* to build stuff.


macro FINAL-FORMS ()
  This macro will expand into any final forms so far registered.
  You need to have finalizers enabled to use this macro.
  In a file that has finalizers enabled, you MUST include (FINAL-FORMS)
  after the last finalizer was used and before the end of the file,
  or the compilation will fail.

function CHECK-FINALIZERS-AROUND-COMPILE (FUN)
  Assuming your system :depends-on (:asdf-finalizers),
  you may use this function as your :around-compile function
  for an ASDF system, module or file, as in
	:around-compile "asdf-finalizers:check-finalizers-around-compile"
  This will allow you to use finalizers within covered source files,
  and will issue an error if you fail to evaluate (FINAL-FORMS)
  after the last finalizer was used and before the end of the file.
  Alternatively, you may use ASDF::FINALIZED-CL-SOURCE-FILE below.
  You may also have your own custom :around-compile hooks
  chain into CHECK-FINALIZERS-AROUND-COMPILE
  to achieve the same effect and more.

class ASDF::FINALIZED-CL-SOURCE-FILE (CL-SOURCE-FILE)
  Assuming your system :defsystem-depends-on (:asdf-finalizers),
  you may use this class as your system's :default-component-class,
  or as the class of a component as in
	(:finalized-cl-source-file "foo" :depends-on ("bar" "baz"))
  This will automatically declare CHECK-FINALIZERS-AROUND-COMPILE
  as the relevant component's :around-compile hook.

function EVAL-AT-TOPLEVEL (FORM &optional ALREADY-DONE-P-FORM WARNING &rest WARNING-ARGUMENTS)
  This function, to be used within a macro, deftype, reader-macro, etc.,
  will evaluate toplevel FORM now during the macroexpansion phase, but also
  register it to be evaluated at the toplevel before the end of current file,
  so it is available to whoever load the associated FASL or CFASL.
  Either now or when loading the (C?)FASL, the evaluation of FORM will be skipped
  when ALREADY-DONE-P-FORM evaluates to a true value.
  When finalizers are not enabled, warn with given warning and arguments or
  with a default warning, unless ALREADY-DONE-P-FORM evaluated to a true value,
  at which point we trust the user to somehow have done the right thing,
  and a build from clean will hopefully catch him if he didn't.

function REGISTER-FINAL-FORM (FORM)
  Register a constant piece of code to the evaluated at toplevel
  at the end of the current code fragment (e.g. file).
  If its effects are to be available at compile-time,
  it will probably enclose these effects in a
    (EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE) ...)

function REGISTER-FINALIZER (THUNK)
  Register a THUNK to be called during finalization.
  Any dependencies must be enforced by calling thunk dependencies.
  Any form returned by the THUNK will be included in the finalized code;
  if its effects are to be available at compile-time,
  it will probably enclose these effects in a
    (EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE) ...)

macro WITH-FINALIZERS (() &body BODY)
  Evaluate BODY in a context where finalizers are enabled.
  By default, don't finalize, because we want to catch code
  that fails to finalize in the same file that requires code finalization.
  For convenience, to test code at the REPL, if FINALIZE is provided and true,
  evaluate finalization forms.

